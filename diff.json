{
  "diff": "diff --git a/src/core/generators/image-hatching.ts b/src/core/generators/image-hatching.ts\nnew file mode 100644\nindex 0000000..6eb1848\n--- /dev/null\n+++ b/src/core/generators/image-hatching.ts\n@@ -0,0 +1,554 @@\n+﻿import MakerJs from 'makerjs';\n+import sharp from 'sharp';\n+\n+export class ImageHatchingParams {\n+    densityMap?: string;\n+    normalMap?: string;\n+    shadingSteps?: number;\n+    density?: number;\n+    baseAngle?: number;\n+    crossHatch?: boolean;\n+    crossHatchChance?: number;\n+    threshold?: number;\n+    scale?: number;\n+    offsetX?: number;\n+    offsetY?: number;\n+    flipX?: boolean;\n+    flipY?: boolean;\n+    minPeriod?: number;      // darkest shading: draw every Nth line (1 = every line)\n+    maxPeriod?: number;      // lightest shading: draw every Nth line (e.g. 6)\n+    densityCurve?: number;   // gamma exponent for the period curve (1=linear, <1=more dense darks, >1=sparser)\n+    drawContour?: boolean;   // trace the boundary of dark regions as a line\n+    contourThreshold?: number; // brightness cutoff for contour detection (default = same as threshold)\n+}\n+\n+export class ImageHatching {\n+    static async generate(\n+        width: number,\n+        height: number,\n+        options: ImageHatchingParams\n+    ): Promise<MakerJs.IModel> {\n+        const model: MakerJs.IModel = { paths: {}, models: {} };\n+\n+        if (!options.densityMap) {\n+            return model;\n+        }\n+\n+        const base64Data = options.densityMap.replace(/^data:image\\/\\w+;base64,/, \"\");\n+        const imageBuffer = Buffer.from(base64Data, 'base64');\n+        // Do NOT call .grayscale() here â€” it strips the alpha channel before ensureAlpha()\n+        // can preserve it, causing transparent pixels to become opaque black.\n+        // Grayscale is computed manually via the luma formula in getDensity().\n+        // Force RGBA (4 channels) so channel indexing is always predictable.\n+        const densitySharp = sharp(imageBuffer);\n+        const rawDensity = await densitySharp\n+            .toColorspace('srgb')\n+            .ensureAlpha()\n+            .raw()\n+            .toBuffer({ resolveWithObject: true });\n+\n+        const dData = rawDensity.data;\n+        const dWidth = rawDensity.info.width;\n+        const dHeight = rawDensity.info.height;\n+\n+        let rawNormal: { data: Buffer, info: sharp.OutputInfo } | null = null;\n+        if (options.normalMap) {\n+            const b64Norm = options.normalMap.replace(/^data:image\\/\\w+;base64,/, \"\");\n+            rawNormal = await sharp(Buffer.from(b64Norm, 'base64'))\n+                .toColorspace('srgb')\n+                .ensureAlpha()\n+                .raw()\n+                .toBuffer({ resolveWithObject: true });\n+        }\n+\n+        const userScale = options.scale ?? 1;\n+        const userOffsetX = options.offsetX ?? 0;\n+        const userOffsetY = options.offsetY ?? 0;\n+\n+        const baseScale = Math.max(width / dWidth, height / dHeight);\n+        const scale = baseScale * userScale;\n+\n+        const imgW = dWidth * scale;\n+        const imgH = dHeight * scale;\n+\n+        const startX = (width - imgW) / 2 + (userOffsetX * width / 100);\n+        const startY = (height - imgH) / 2 + (userOffsetY * height / 100);\n+\n+        // Bilinear interpolation for smooth anti-aliased edges\n+        const getDensity = (x: number, y: number): number => {\n+            // Sub-pixel position in image space (with Y flip)\n+            const fx = (x - startX) / scale;\n+            const fy = (startY + imgH - y) / scale;\n+\n+            const applyFlipX = (px: number) => options.flipX ? (dWidth - 1) - px : px;\n+            const applyFlipY = (py: number) => options.flipY ? (dHeight - 1) - py : py;\n+\n+            const samplePixel = (px: number, py: number): number => {\n+                const bx = applyFlipX(Math.max(0, Math.min(dWidth - 1, px)));\n+                const by = applyFlipY(Math.max(0, Math.min(dHeight - 1, py)));\n+                const channels = rawDensity.info.channels;\n+                const idx = (by * dWidth + bx) * channels;\n+\n+                let r, g, b, a;\n+                if (channels >= 4) {\n+                    r = dData[idx]; g = dData[idx + 1]; b = dData[idx + 2]; a = dData[idx + 3];\n+                } else if (channels === 3) {\n+                    r = dData[idx]; g = dData[idx + 1]; b = dData[idx + 2]; a = 255;\n+                } else if (channels === 2) {\n+                    r = dData[idx]; g = dData[idx]; b = dData[idx]; a = dData[idx + 1];\n+                } else {\n+                    r = dData[idx]; g = dData[idx]; b = dData[idx]; a = 255;\n+                }\n+\n+                if (a === 0) return 1;\n+                const alpha = a / 255;\n+                const bR = r * alpha + 255 * (1 - alpha);\n+                const bG = g * alpha + 255 * (1 - alpha);\n+                const bB = b * alpha + 255 * (1 - alpha);\n+                return (bR * 0.299 + bG * 0.587 + bB * 0.114) / 255;\n+            };\n+\n+            // Outside image bounds â†’ white\n+            if (fx < -0.5 || fx >= dWidth - 0.5 || fy < -0.5 || fy >= dHeight - 0.5) return 1;\n+\n+            // Bilinear interpolation\n+            const x0 = Math.floor(fx);\n+            const y0 = Math.floor(fy);\n+            const tx = fx - x0;\n+            const ty = fy - y0;\n+\n+            const s00 = samplePixel(x0, y0);\n+            const s10 = samplePixel(x0 + 1, y0);\n+            const s01 = samplePixel(x0, y0 + 1);\n+            const s11 = samplePixel(x0 + 1, y0 + 1);\n+\n+            return s00 * (1 - tx) * (1 - ty)\n+                + s10 * tx * (1 - ty)\n+                + s01 * (1 - tx) * ty\n+                + s11 * tx * ty;\n+        };\n+\n+        // ── Normal Map Tangent Sampling ─────────────────────────────────────────\n+        const getTangent = (x: number, y: number): { vx: number, vy: number } | null => {\n+            if (!rawNormal) return null;\n+            const fx = (x - startX) / scale;\n+            const fy = (startY + imgH - y) / scale;\n+\n+            // Outside image bounds â†’ flow straight horizontally as fallback\n+            if (fx < -0.5 || fx >= dWidth - 0.5 || fy < -0.5 || fy >= dHeight - 0.5) return null;\n+\n+            const applyFlipX = (px: number) => options.flipX ? (dWidth - 1) - px : px;\n+            const applyFlipY = (py: number) => options.flipY ? (dHeight - 1) - py : py;\n+\n+            const bx = applyFlipX(Math.max(0, Math.min(dWidth - 1, Math.round(fx))));\n+            const by = applyFlipY(Math.max(0, Math.min(dHeight - 1, Math.round(fy))));\n+\n+            const nChannels = rawNormal.info.channels;\n+            const idx = (by * dWidth + bx) * nChannels;\n+\n+            // R: X-axis (-1 left to 1 right)\n+            // G: Y-axis (-1 down to 1 up)\n+            // B: Z-axis (forward)\n+            const r = rawNormal.data[idx];\n+            const g = rawNormal.data[idx + 1];\n+\n+            // Remap [0, 255] to [-1.0, 1.0]\n+            // Standard normal map: R=128, G=128 is \"flat\" (facing camera)\n+            const nx = (r / 255) * 2.0 - 1.0;\n+            // IMPORTANT: Normal map G channel conventions vary (DirectX vs OpenGL).\n+            // Usually Y goes *up*, but image coords go down. We assume standard +Y=Up.\n+            let ny = (g / 255) * 2.0 - 1.0;\n+            if (options.flipY) ny = -ny; // User flip might affect normal direction\n+\n+            // The surface normal is (nx, ny, nz).\n+            // To hatch *along* the surface, we want a tangent.\n+            // Rotating the XY normal vector by 90Â° gives a tangent flow direction: [-ny, nx].\n+            let tx = -ny;\n+            let ty = nx;\n+\n+            const len = Math.hypot(tx, ty);\n+            if (len < 0.001) return null; // Flat area: fallback\n+\n+            return { vx: tx / len, vy: ty / len };\n+        };\n+\n+        const baseAngleRad = (options.baseAngle || 45) * Math.PI / 180;\n+        const threshold = options.threshold ?? 0.95;\n+        const densityMultiplier = Math.max(0.1, options.density || 1.5);\n+        const steps = Math.floor(Math.max(1, options.shadingSteps || 5));\n+\n+        const baseMinSpacing = 2.0;\n+        const minSpacing = baseMinSpacing / densityMultiplier;\n+\n+        // Period controls: how many scan lines to skip per shading level\n+        const periodMin = Math.max(1, Math.round(options.minPeriod ?? 1));\n+        const periodMax = Math.max(periodMin, Math.round(options.maxPeriod ?? 6));\n+        // densityCurve: gamma exponent applied to the normalised darkness before mapping to period\n+        // <1 = more lines in dark areas (emphasises darks), >1 = sparsely spaced (emphasises lights)\n+        const densityCurve = Math.max(0.1, options.densityCurve ?? 1.0);\n+\n+        // â”€â”€ Shared Boundary Segments â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n+        // buildBoundary() runs the strand-accumulation contour scan, applies smoothing,\n+        // and returns a flat list of [x1,y1,x2,y2] segments in world (canvas) space.\n+        // These are used both for drawing the contour line AND for clipping hatch lines,\n+        // so both operations share exactly the same clean edge.\n+        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n+        interface Seg2D { x1: number; y1: number; x2: number; y2: number; }\n+\n+        const buildBoundary = (bThresh: number): Seg2D[] => {\n+            const cSpacingY = minSpacing * 0.4;\n+            const cStepX = 0.25;\n+            const maxGap = Math.max(cSpacingY * 8, 3.0);\n+\n+            type Strand = { pts: MakerJs.IPoint[] };\n+            let activeStrands: Strand[] = [];\n+\n+            // Smooth weights [1,2,4,2,1]/10\n+            const smW = [1, 2, 4, 2, 1];\n+            const smWsum = 10;\n+\n+            const smoothPts = (pts: MakerJs.IPoint[]): MakerJs.IPoint[] =>\n+                pts.map((_, i) => {\n+                    let sx = 0, sy = 0;\n+                    for (let k = -2; k <= 2; k++) {\n+                        const j = Math.max(0, Math.min(pts.length - 1, i + k));\n+                        sx += pts[j][0] * smW[k + 2];\n+                        sy += pts[j][1] * smW[k + 2];\n+                    }\n+                    return [sx / smWsum, sy / smWsum] as MakerJs.IPoint;\n+                });\n+\n+            const resultSegs: Seg2D[] = [];\n+\n+            const flushStrand = (s: Strand) => {\n+                if (s.pts.length < 2) return;\n+                const sm = smoothPts(s.pts);\n+                for (let i = 0; i < sm.length - 1; i++) {\n+                    resultSegs.push({ x1: sm[i][0], y1: sm[i][1], x2: sm[i + 1][0], y2: sm[i + 1][1] });\n+                }\n+            };\n+\n+            for (let sy = 0; sy <= height; sy += cSpacingY) {\n+                const rowCrossings: MakerJs.IPoint[] = [];\n+                let prevD = 1.0, prevPx = 0.0;\n+\n+                for (let sx = 0; sx <= width; sx += cStepX) {\n+                    const d = getDensity(sx, sy);\n+                    if ((prevD >= bThresh) !== (d >= bThresh) && d !== prevD) {\n+                        const t = (bThresh - prevD) / (d - prevD);\n+                        rowCrossings.push([prevPx + t * cStepX, sy]);\n+                    }\n+                    prevD = d; prevPx = sx;\n+                }\n+\n+                const matchedStrand = new Set<number>();\n+                const matchedCross = new Set<number>();\n+                const nextStrands: Strand[] = [];\n+\n+                for (let si = 0; si < activeStrands.length; si++) {\n+                    const lastPt = activeStrands[si].pts[activeStrands[si].pts.length - 1];\n+                    let bestDist = maxGap, bestCi = -1;\n+                    for (let ci = 0; ci < rowCrossings.length; ci++) {\n+                        if (matchedCross.has(ci)) continue;\n+                        const dist = Math.abs(rowCrossings[ci][0] - lastPt[0]);\n+                        if (dist < bestDist) { bestDist = dist; bestCi = ci; }\n+                    }\n+                    if (bestCi >= 0) {\n+                        matchedStrand.add(si); matchedCross.add(bestCi);\n+                        activeStrands[si].pts.push(rowCrossings[bestCi]);\n+                        nextStrands.push(activeStrands[si]);\n+                    }\n+                }\n+                for (let si = 0; si < activeStrands.length; si++) {\n+                    if (!matchedStrand.has(si)) flushStrand(activeStrands[si]);\n+                }\n+                for (let ci = 0; ci < rowCrossings.length; ci++) {\n+                    if (!matchedCross.has(ci)) nextStrands.push({ pts: [rowCrossings[ci]] });\n+                }\n+                activeStrands = nextStrands;\n+            }\n+            for (const s of activeStrands) flushStrand(s);\n+            return resultSegs;\n+        };\n+\n+        // â”€â”€ Scan-line Ã— boundary intersection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n+        // For a scan line at perpendicular offset y (in rotated frame), direction cosA/sinA,\n+        // find all x-parameters along the scan line where it crosses boundary segment seg.\n+        //\n+        // Scan point at param x: world = (cx + xÂ·cosA âˆ’ yÂ·sinA,  cy + xÂ·sinA + yÂ·cosA)\n+        // Segment from A to B:   world = A + tÂ·(Bâˆ’A),  t âˆˆ [0,1]\n+        //\n+        // 2Ã—2 system (Cramer's rule):\n+        //   xÂ·cosA âˆ’ tÂ·ddx = rx    where rx = Ax âˆ’ cx + yÂ·sinA\n+        //   xÂ·sinA âˆ’ tÂ·ddy = ry          ry = Ay âˆ’ cy âˆ’ yÂ·cosA\n+        //   det = ddxÂ·sinA âˆ’ cosAÂ·ddy\n+        //   x   = (âˆ’rxÂ·ddy + ryÂ·ddx) / det\n+        //   t   = ( cosAÂ·ry âˆ’ sinAÂ·rx) / det\n+        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n+        const hatchClipXValues = (\n+            cx: number, cy: number,\n+            cosA: number, sinA: number,\n+            y: number,\n+            segs: Seg2D[]\n+        ): number[] => {\n+            const hits: number[] = [];\n+            for (const seg of segs) {\n+                const ddx = seg.x2 - seg.x1;\n+                const ddy = seg.y2 - seg.y1;\n+                const det = ddx * sinA - cosA * ddy;\n+                if (Math.abs(det) < 1e-8) continue;\n+                const rx = seg.x1 - cx + y * sinA;\n+                const ry = seg.y1 - cy - y * cosA;\n+                const tSeg = (cosA * ry - sinA * rx) / det;\n+                if (tSeg < -1e-6 || tSeg > 1 + 1e-6) continue;\n+                const xParam = (-rx * ddy + ry * ddx) / det;\n+                hits.push(xParam);\n+            }\n+            hits.sort((a, b) => a - b);\n+            return hits;\n+        };\n+\n+        // â”€â”€ Raster Hatching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n+        const runRasterHatching = (angleOffset: number, boundarySegs: Seg2D[] | null) => {\n+            const angle = baseAngleRad + angleOffset;\n+            const cosA = Math.cos(angle);\n+            const sinA = Math.sin(angle);\n+\n+            const maxRadius = Math.hypot(width, height) / 2;\n+            const cx = width / 2;\n+            const cy = height / 2;\n+\n+            const yMin = -maxRadius;\n+            const yMax = maxRadius;\n+            const xMin = -maxRadius;\n+            const xMax = maxRadius;\n+\n+            let lineIdCounter = 0;\n+            const R = (v: number) => Math.round(v * 1000) / 1000;\n+\n+            for (let y = yMin; y <= yMax; y += minSpacing) {\n+                const lineIndex = Math.round(Math.abs((y - yMin) / minSpacing));\n+                const stepX = 0.5;\n+\n+                // â”€â”€ Determine active x-ranges for this scan line â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n+                // If boundary segments are provided, use them for the clip; otherwise\n+                // fall back to density threshold (old behaviour).\n+                type Range = { xStart: number; xEnd: number };\n+                const activeRanges: Range[] = [];\n+\n+                if (boundarySegs && boundarySegs.length > 0) {\n+                    const hits = hatchClipXValues(cx, cy, cosA, sinA, y, boundarySegs);\n+                    // Pair intersections: even-odd fill rule\n+                    for (let hi = 0; hi + 1 < hits.length; hi += 2) {\n+                        activeRanges.push({ xStart: hits[hi], xEnd: hits[hi + 1] });\n+                    }\n+                }\n+\n+                // â”€â”€ Emit hatch segments within each active range â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n+                for (const range of activeRanges) {\n+                    let currentSegment: MakerJs.IPoint[] = [];\n+\n+                    const emitSeg = () => {\n+                        if (currentSegment.length === 2) {\n+                            const len = Math.hypot(\n+                                currentSegment[0][0] - currentSegment[1][0],\n+                                currentSegment[0][1] - currentSegment[1][1]\n+                            );\n+                            if (len > 0.5) {\n+                                model.models![`hatch_${angleOffset}_${lineIdCounter++}`] =\n+                                    new MakerJs.models.ConnectTheDots(false, [...currentSegment]);\n+                            }\n+                        }\n+                        currentSegment = [];\n+                    };\n+\n+                    // Clip range endpoints to canvas and to xMin/xMax\n+                    const xStart = Math.max(xMin, range.xStart);\n+                    const xEnd = Math.min(xMax, range.xEnd);\n+\n+                    for (let x = xStart; x <= xEnd; x = Math.min(x + stepX, xEnd)) {\n+                        const rx = cx + x * cosA - y * sinA;\n+                        const ry = cy + x * sinA + y * cosA;\n+                        const inBounds = rx >= 0 && rx <= width && ry >= 0 && ry <= height;\n+                        const dens = inBounds ? getDensity(rx, ry) : 1.0;\n+\n+                        let draw = false;\n+                        if (inBounds && dens < threshold) {\n+                            const darkness = 1.0 - dens;\n+                            let normalizedDarkness = Math.max(0, darkness - (1.0 - threshold)) / threshold;\n+                            normalizedDarkness = Math.min(1.0, normalizedDarkness);\n+                            const bucketIndex = Math.floor(normalizedDarkness * (steps - 0.001));\n+\n+                            let isSwitched = false;\n+                            const chance = options.crossHatchChance || 0;\n+                            if (chance > 0) {\n+                                if (chance >= 1.0) { isSwitched = (bucketIndex % 2 === 1); }\n+                                else { const h = Math.sin((bucketIndex + 1) * 123.456) * 10000; isSwitched = (h - Math.floor(h)) < chance; }\n+                            }\n+\n+                            let shouldDrawPass = false;\n+                            const isAltPass = Math.abs(angleOffset) > 0.01;\n+                            if (options.crossHatch) shouldDrawPass = true;\n+                            else shouldDrawPass = isAltPass ? isSwitched : !isSwitched;\n+\n+                            if (shouldDrawPass) {\n+                                const tBucket = steps > 1 ? bucketIndex / (steps - 1) : 1;\n+                                const tCurved = Math.pow(tBucket, densityCurve);\n+                                const period = Math.round(periodMax * (1 - tCurved) + periodMin * tCurved);\n+                                if (lineIndex % period === 0) draw = true;\n+                            }\n+                        }\n+\n+                        if (draw) {\n+                            if (currentSegment.length === 0) currentSegment.push([R(rx), R(ry)]);\n+                            else if (currentSegment.length === 1) currentSegment.push([R(rx), R(ry)]);\n+                            else currentSegment[1] = [R(rx), R(ry)];\n+                        } else if (currentSegment.length > 0) {\n+                            if (currentSegment.length < 2) currentSegment.push([R(rx), R(ry)]);\n+                            emitSeg();\n+                        }\n+\n+                        if (x >= xEnd) break;\n+                    }\n+\n+                    // Flush last segment â€” use exact boundary point as endpoint\n+                    if (currentSegment.length > 0) {\n+                        const endRx = cx + range.xEnd * cosA - y * sinA;\n+                        const endRy = cy + range.xEnd * sinA + y * cosA;\n+                        if (currentSegment.length < 2) currentSegment.push([R(endRx), R(endRy)]);\n+                        else currentSegment[1] = [R(endRx), R(endRy)];\n+                        emitSeg();\n+                    }\n+                }\n+\n+                // â”€â”€ Fallback: no boundary â€” use density threshold scan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n+                if (!boundarySegs || boundarySegs.length === 0) {\n+                    let prevDens = 1.0;\n+                    let prevRx = cx + xMin * cosA - y * sinA;\n+                    let prevRy = cy + xMin * sinA + y * cosA;\n+                    let prevDraw = false;\n+                    let currentSegment: MakerJs.IPoint[] = [];\n+\n+                    const emitSeg = () => {\n+                        if (currentSegment.length === 2) {\n+                            const len = Math.hypot(currentSegment[0][0] - currentSegment[1][0], currentSegment[0][1] - currentSegment[1][1]);\n+                            if (len > 0.5) {\n+                                model.models![`hatch_${angleOffset}_${lineIdCounter++}`] =\n+                                    new MakerJs.models.ConnectTheDots(false, [...currentSegment]);\n+                            }\n+                        }\n+                        currentSegment = [];\n+                    };\n+\n+                    for (let x = xMin; x <= xMax; x += stepX) {\n+                        const rx = cx + x * cosA - y * sinA;\n+                        const ry = cy + x * sinA + y * cosA;\n+                        const inBounds = rx >= 0 && rx <= width && ry >= 0 && ry <= height;\n+                        const dens = inBounds ? getDensity(rx, ry) : 1.0;\n+                        let draw = false;\n+                        if (inBounds && dens < threshold) {\n+                            const darkness = 1.0 - dens;\n+                            let nd = Math.max(0, darkness - (1.0 - threshold)) / threshold;\n+                            nd = Math.min(1.0, nd);\n+                            const bi = Math.floor(nd * (steps - 0.001));\n+                            let sw = false;\n+                            const ch = options.crossHatchChance || 0;\n+                            if (ch > 0) { if (ch >= 1) sw = (bi % 2 === 1); else { const h = Math.sin((bi + 1) * 123.456) * 10000; sw = (h - Math.floor(h)) < ch; } }\n+                            let sdp = false;\n+                            const alt = Math.abs(angleOffset) > 0.01;\n+                            if (options.crossHatch) sdp = true; else sdp = alt ? sw : !sw;\n+                            if (sdp) {\n+                                const tB = steps > 1 ? bi / (steps - 1) : 1;\n+                                const tC = Math.pow(tB, densityCurve);\n+                                const per = Math.round(periodMax * (1 - tC) + periodMin * tC);\n+                                if (lineIndex % per === 0) draw = true;\n+                            }\n+                        }\n+                        if (draw && !prevDraw) {\n+                            let sRx = rx, sRy = ry;\n+                            if (prevDens >= threshold && dens < threshold && dens !== prevDens) {\n+                                const t = (threshold - prevDens) / (dens - prevDens);\n+                                sRx = prevRx + t * (rx - prevRx); sRy = prevRy + t * (ry - prevRy);\n+                            }\n+                            currentSegment = [[R(sRx), R(sRy)]];\n+                        } else if (!draw && prevDraw) {\n+                            let eRx = prevRx, eRy = prevRy;\n+                            if (prevDens < threshold && dens >= threshold && dens !== prevDens) {\n+                                const t = (threshold - prevDens) / (dens - prevDens);\n+                                eRx = prevRx + t * (rx - prevRx); eRy = prevRy + t * (ry - prevRy);\n+                            }\n+                            if (currentSegment.length >= 1) {\n+                                if (currentSegment.length === 1) currentSegment.push([R(eRx), R(eRy)]);\n+                                else currentSegment[1] = [R(eRx), R(eRy)];\n+                            }\n+                            emitSeg();\n+                        } else if (draw) {\n+                            if (currentSegment.length === 1) currentSegment.push([R(rx), R(ry)]);\n+                            else currentSegment[1] = [R(rx), R(ry)];\n+                        }\n+                        prevDens = dens; prevRx = rx; prevRy = ry; prevDraw = draw;\n+                    }\n+                    if (prevDraw && currentSegment.length >= 1) {\n+                        if (currentSegment.length === 1) currentSegment.push([R(prevRx), R(prevRy)]);\n+                        emitSeg();\n+                    }\n+                }\n+            }\n+        };\n+\n+        // â”€â”€ Build boundary, run hatching, optionally draw contour â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n+        const bThresh = options.contourThreshold ?? threshold;\n+        const boundary = buildBoundary(bThresh);\n+\n+        runRasterHatching(0, boundary);\n+        if (options.crossHatch || (options.crossHatchChance || 0) > 0) {\n+            runRasterHatching(Math.PI / 2, boundary);\n+        }\n+\n+        // Draw contour lines by emitting the boundary segments into the model\n+        if (options.drawContour && boundary.length > 0) {\n+            let contourId = 0;\n+            // Re-run strand accumulation on raw segments to emit as polylines\n+            // (the boundary segs are already smoothed, so just chain consecutive ones)\n+            // Group segments into polylines by proximity\n+            type CStrand = MakerJs.IPoint[];\n+            const strands: CStrand[] = [];\n+            const usedSeg = new Set<number>();\n+\n+            for (let si = 0; si < boundary.length; si++) {\n+                if (usedSeg.has(si)) continue;\n+                usedSeg.add(si);\n+                const strand: CStrand = [\n+                    [boundary[si].x1, boundary[si].y1],\n+                    [boundary[si].x2, boundary[si].y2]\n+                ];\n+                // Chain segments that share endpoints\n+                let extended = true;\n+                while (extended) {\n+                    extended = false;\n+                    const last = strand[strand.length - 1];\n+                    for (let sj = 0; sj < boundary.length; sj++) {\n+                        if (usedSeg.has(sj)) continue;\n+                        const distToStart = Math.hypot(boundary[sj].x1 - last[0], boundary[sj].y1 - last[1]);\n+                        if (distToStart < 0.01) {\n+                            usedSeg.add(sj);\n+                            strand.push([boundary[sj].x2, boundary[sj].y2]);\n+                            extended = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+                strands.push(strand);\n+            }\n+\n+            for (const strand of strands) {\n+                if (strand.length >= 2) {\n+                    model.models![`contour_${contourId++}`] =\n+                        new MakerJs.models.ConnectTheDots(false, strand);\n+                }\n+            }\n+        }\n+\n+        return model;\n+    }\n+}\n"
}