import MakerJs from 'makerjs';
import { GCodeConfig } from '../types';

interface InternalGCodeConfig extends GCodeConfig {
    precision: number;
}

const DEFAULT_CONFIG: InternalGCodeConfig = {
    feedRate: 1500,
    zUp: 0,     // e.g. Servo Angle
    zDown: 45,  // e.g. Servo Angle
    precision: 2
};

export class GCodeExporter {
    static export(model: MakerJs.IModel, config: Partial<InternalGCodeConfig> = {}): string {
        const cfg = { ...DEFAULT_CONFIG, ...config };
        const lines: string[] = [];

        // Header
        lines.push('; Generated by Drawing Maker');
        lines.push('G21 ; Units MM');
        lines.push('G90 ; Absolute Positioning');
        lines.push(`G0 Z${cfg.zUp} ; Pen Up`);
        lines.push(`G0 F${cfg.feedRate} ; Set Feedrate`);

        // We use finding chains to optimize travel (don't lift pen if lines connect)
        // Options: byLayers: false, pointMatchingDistance: 0.1
        const options = { pointMatchingDistance: 0.05 };
        const chains = MakerJs.model.findChains(model, options) as MakerJs.IChain[];


        // 3a. Optimize: Sort chains to minimize travel distance
        // Greedy Nearest Neighbor
        const sortedChains: MakerJs.IChain[] = [];
        let pool = [...chains];
        let currentPos = { x: 0, y: 0 }; // Start at home

        while (pool.length > 0) {
            let bestIdx = -1;
            let bestDist = Infinity;
            let bestReverse = false;

            for (let i = 0; i < pool.length; i++) {
                const chain = pool[i];
                if (!chain.links.length) continue;

                // Check normal direction (Start of chain)
                const start = chain.links[0].endPoints[0];
                const distStart = Math.hypot(start[0] - currentPos.x, start[1] - currentPos.y);

                if (distStart < bestDist) {
                    bestDist = distStart;
                    bestIdx = i;
                    bestReverse = false;
                }

                // Check reverse direction (End of chain)
                // We treat the "end" of the chain as a potential start point if we reverse it
                const end = chain.links[chain.links.length - 1].endPoints[1];
                const distEnd = Math.hypot(end[0] - currentPos.x, end[1] - currentPos.y);

                if (distEnd < bestDist) {
                    bestDist = distEnd;
                    bestIdx = i;
                    bestReverse = true;
                }
            }

            if (bestIdx !== -1) {
                const bestChain = pool[bestIdx];
                pool.splice(bestIdx, 1);

                if (bestReverse) {
                    // Reverse the chain logic directly here or use a helper
                    // MakerJs chain reversal is non-trivial to mutate, so we will handle it by 
                    // iterating backwards in step 4.
                    (bestChain as any)._reverseExport = true;
                    // Update current pos to the "start" (which was the old end)
                    const startRaw = bestChain.links[bestChain.links.length - 1].endPoints[1];
                    currentPos = { x: startRaw[0], y: startRaw[1] };
                } else {
                    (bestChain as any)._reverseExport = false;
                    // Update current pos to the end
                    const endRaw = bestChain.links[bestChain.links.length - 1].endPoints[1];
                    currentPos = { x: endRaw[0], y: endRaw[1] };
                }

                sortedChains.push(bestChain);
            } else {
                // Should not happen unless pool has empty chains
                pool = [];
            }
        }

        sortedChains.forEach((chain: MakerJs.IChain) => {
            // A chain allows us to move to the start, pen down, and draw the whole sequence
            // chain.links contains the paths
            // chain.endless tells us if it's a loop

            if (chain.links.length === 0) return;

            const isReverse = (chain as any)._reverseExport;

            // If reverse, our "start" is the LAST link's point 1
            // If normal, our "start" is the FIRST link's point 0

            const startPoint = isReverse
                ? chain.links[chain.links.length - 1].endPoints[1]
                : chain.links[0].endPoints[0];

            lines.push(`G0 X${startPoint[0].toFixed(cfg.precision)} Y${startPoint[1].toFixed(cfg.precision)}`);

            // 2. Pen Down
            lines.push(`G0 Z${cfg.zDown}`);

            // 3. Draw each segment
            if (isReverse) {
                // Iterate backwards
                for (let i = chain.links.length - 1; i >= 0; i--) {
                    const link = chain.links[i];
                    // Verify geometry: if link goes A->B, and we assume we are at B, we want to go linked to A
                    // G1 to point 0
                    const nextP = link.endPoints[0]; // The other end
                    lines.push(`G1 X${nextP[0].toFixed(cfg.precision)} Y${nextP[1].toFixed(cfg.precision)}`);
                }
            } else {
                // Iterate forwards
                for (let i = 0; i < chain.links.length; i++) {
                    const link = chain.links[i];
                    const nextP = link.endPoints[1];
                    lines.push(`G1 X${nextP[0].toFixed(cfg.precision)} Y${nextP[1].toFixed(cfg.precision)}`);
                }
            }

            // 4. Pen Up at end of chain
            lines.push(`G0 Z${cfg.zUp}`);
        });

        // Footer
        lines.push('G0 X0 Y0 ; Return Home');
        lines.push('M02 ; End of Program');

        return lines.join('\n');
    }

    /**
     * Export multiple layers as a single combined G-code file.
     * Combines all layer models before chain optimization.
     * Adds comments to indicate layer boundaries.
     * 
     * @param layers Map of layer IDs to models
     * @param config G-code configuration
     * @returns Combined G-code string
     */
    static exportLayers(layers: Map<string, MakerJs.IModel>, config: Partial<InternalGCodeConfig> = {}): string {
        const cfg = { ...DEFAULT_CONFIG, ...config };
        const lines: string[] = [];

        // Header
        lines.push('; Generated by Drawing Maker - Multi-Layer Export');
        lines.push('G21 ; Units MM');
        lines.push('G90 ; Absolute Positioning');
        lines.push(`G0 Z${cfg.zUp} ; Pen Up`);
        lines.push(`G0 F${cfg.feedRate} ; Set Feedrate`);
        lines.push('');

        // Combine all layer models into one for optimized chain finding
        const combined: MakerJs.IModel = { paths: {}, models: {} };
        let pathCounter = 0;
        let modelCounter = 0;

        for (const [layerId, model] of layers.entries()) {
            lines.push(`; === Layer: ${layerId} ===`);

            // Add paths with unique keys
            if (model.paths) {
                for (const [key, path] of Object.entries(model.paths)) {
                    combined.paths![`${layerId}_${pathCounter++}`] = path;
                }
            }

            // Add models with unique keys
            if (model.models) {
                for (const [key, subModel] of Object.entries(model.models)) {
                    combined.models![`${layerId}_${modelCounter++}`] = subModel;
                }
            }
        }

        // Find chains across all layers for optimization
        const options = { pointMatchingDistance: 0.05 };
        const chains = MakerJs.model.findChains(combined, options) as MakerJs.IChain[];

        // Optimize chain order (greedy nearest neighbor)
        const sortedChains: MakerJs.IChain[] = [];
        let pool = [...chains];
        let currentPos = { x: 0, y: 0 };

        while (pool.length > 0) {
            let bestIdx = -1;
            let bestDist = Infinity;
            let bestReverse = false;

            for (let i = 0; i < pool.length; i++) {
                const chain = pool[i];
                if (!chain.links.length) continue;

                const start = chain.links[0].endPoints[0];
                const distStart = Math.hypot(start[0] - currentPos.x, start[1] - currentPos.y);

                if (distStart < bestDist) {
                    bestDist = distStart;
                    bestIdx = i;
                    bestReverse = false;
                }

                const end = chain.links[chain.links.length - 1].endPoints[1];
                const distEnd = Math.hypot(end[0] - currentPos.x, end[1] - currentPos.y);

                if (distEnd < bestDist) {
                    bestDist = distEnd;
                    bestIdx = i;
                    bestReverse = true;
                }
            }

            if (bestIdx !== -1) {
                const bestChain = pool[bestIdx];
                pool.splice(bestIdx, 1);

                if (bestReverse) {
                    (bestChain as any)._reverseExport = true;
                    const startRaw = bestChain.links[bestChain.links.length - 1].endPoints[1];
                    currentPos = { x: startRaw[0], y: startRaw[1] };
                } else {
                    (bestChain as any)._reverseExport = false;
                    const endRaw = bestChain.links[bestChain.links.length - 1].endPoints[1];
                    currentPos = { x: endRaw[0], y: endRaw[1] };
                }

                sortedChains.push(bestChain);
            } else {
                pool = [];
            }
        }

        // Generate G-code for all chains
        sortedChains.forEach((chain: MakerJs.IChain) => {
            if (chain.links.length === 0) return;

            const isReverse = (chain as any)._reverseExport;
            const startPoint = isReverse
                ? chain.links[chain.links.length - 1].endPoints[1]
                : chain.links[0].endPoints[0];

            lines.push(`G0 X${startPoint[0].toFixed(cfg.precision)} Y${startPoint[1].toFixed(cfg.precision)}`);
            lines.push(`G0 Z${cfg.zDown}`);

            if (isReverse) {
                for (let i = chain.links.length - 1; i >= 0; i--) {
                    const link = chain.links[i];
                    const nextP = link.endPoints[0];
                    lines.push(`G1 X${nextP[0].toFixed(cfg.precision)} Y${nextP[1].toFixed(cfg.precision)}`);
                }
            } else {
                for (let i = 0; i < chain.links.length; i++) {
                    const link = chain.links[i];
                    const nextP = link.endPoints[1];
                    lines.push(`G1 X${nextP[0].toFixed(cfg.precision)} Y${nextP[1].toFixed(cfg.precision)}`);
                }
            }

            lines.push(`G0 Z${cfg.zUp}`);
        });

        // Footer
        lines.push('');
        lines.push('G0 X0 Y0 ; Return Home');
        lines.push('M02 ; End of Program');

        return lines.join('\n');
    }

    /**
     * Export each layer as a separate G-code file.
     * Returns a map of layer IDs to their complete G-code strings.
     * Each G-code file is independent and ready to run.
     * 
     * @param layers Map of layer IDs to models
     * @param config G-code configuration
     * @returns Map of layer IDs to G-code strings
     */
    static exportLayersIndividual(layers: Map<string, MakerJs.IModel>, config: Partial<InternalGCodeConfig> = {}): Map<string, string> {
        const result = new Map<string, string>();

        for (const [layerId, model] of layers.entries()) {
            // Export each layer using the standard export method
            const gcode = GCodeExporter.export(model, config);
            result.set(layerId, gcode);
        }

        return result;
    }
}
