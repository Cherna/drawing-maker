import MakerJs from 'makerjs';

export interface GCodeConfig {
    feedRate: number;
    zUp: number;
    zDown: number;
    precision: number;
}

const DEFAULT_CONFIG: GCodeConfig = {
    feedRate: 1500,
    zUp: 0,     // e.g. Servo Angle
    zDown: 45,  // e.g. Servo Angle
    precision: 2
};

export class GCodeExporter {
    static export(model: MakerJs.IModel, config: Partial<GCodeConfig> = {}): string {
        const cfg = { ...DEFAULT_CONFIG, ...config };
        const lines: string[] = [];

        // Header
        lines.push('; Generated by Drawing Maker');
        lines.push('G21 ; Units MM');
        lines.push('G90 ; Absolute Positioning');
        lines.push(`G0 Z${cfg.zUp} ; Pen Up`);
        lines.push(`G0 F${cfg.feedRate} ; Set Feedrate`);

        // We use finding chains to optimize travel (don't lift pen if lines connect)
        // Options: byLayers: false, pointMatchingDistance: 0.1
        const options = { pointMatchingDistance: 0.05 };
        const chains = MakerJs.model.findChains(model, options) as MakerJs.IChain[];


        // 3a. Optimize: Sort chains to minimize travel distance
        // Greedy Nearest Neighbor
        const sortedChains: MakerJs.IChain[] = [];
        let pool = [...chains];
        let currentPos = { x: 0, y: 0 }; // Start at home

        while (pool.length > 0) {
            let bestIdx = -1;
            let bestDist = Infinity;
            let bestReverse = false;

            for (let i = 0; i < pool.length; i++) {
                const chain = pool[i];
                if (!chain.links.length) continue;

                // Check normal direction (Start of chain)
                const start = chain.links[0].endPoints[0];
                const distStart = Math.hypot(start[0] - currentPos.x, start[1] - currentPos.y);

                if (distStart < bestDist) {
                    bestDist = distStart;
                    bestIdx = i;
                    bestReverse = false;
                }

                // Check reverse direction (End of chain)
                // We treat the "end" of the chain as a potential start point if we reverse it
                const end = chain.links[chain.links.length - 1].endPoints[1];
                const distEnd = Math.hypot(end[0] - currentPos.x, end[1] - currentPos.y);

                if (distEnd < bestDist) {
                    bestDist = distEnd;
                    bestIdx = i;
                    bestReverse = true;
                }
            }

            if (bestIdx !== -1) {
                const bestChain = pool[bestIdx];
                pool.splice(bestIdx, 1);

                if (bestReverse) {
                    // Reverse the chain logic directly here or use a helper
                    // MakerJs chain reversal is non-trivial to mutate, so we will handle it by 
                    // iterating backwards in step 4.
                    (bestChain as any)._reverseExport = true;
                    // Update current pos to the "start" (which was the old end)
                    const startRaw = bestChain.links[bestChain.links.length - 1].endPoints[1];
                    currentPos = { x: startRaw[0], y: startRaw[1] };
                } else {
                    (bestChain as any)._reverseExport = false;
                    // Update current pos to the end
                    const endRaw = bestChain.links[bestChain.links.length - 1].endPoints[1];
                    currentPos = { x: endRaw[0], y: endRaw[1] };
                }

                sortedChains.push(bestChain);
            } else {
                // Should not happen unless pool has empty chains
                pool = [];
            }
        }

        sortedChains.forEach((chain: MakerJs.IChain) => {
            // A chain allows us to move to the start, pen down, and draw the whole sequence
            // chain.links contains the paths
            // chain.endless tells us if it's a loop

            if (chain.links.length === 0) return;

            const isReverse = (chain as any)._reverseExport;

            // If reverse, our "start" is the LAST link's point 1
            // If normal, our "start" is the FIRST link's point 0

            const startPoint = isReverse
                ? chain.links[chain.links.length - 1].endPoints[1]
                : chain.links[0].endPoints[0];

            lines.push(`G0 X${startPoint[0].toFixed(cfg.precision)} Y${startPoint[1].toFixed(cfg.precision)}`);

            // 2. Pen Down
            lines.push(`G0 Z${cfg.zDown}`);

            // 3. Draw each segment
            if (isReverse) {
                // Iterate backwards
                for (let i = chain.links.length - 1; i >= 0; i--) {
                    const link = chain.links[i];
                    // Verify geometry: if link goes A->B, and we assume we are at B, we want to go linked to A
                    // G1 to point 0
                    const nextP = link.endPoints[0]; // The other end
                    lines.push(`G1 X${nextP[0].toFixed(cfg.precision)} Y${nextP[1].toFixed(cfg.precision)}`);
                }
            } else {
                // Iterate forwards
                for (let i = 0; i < chain.links.length; i++) {
                    const link = chain.links[i];
                    const nextP = link.endPoints[1];
                    lines.push(`G1 X${nextP[0].toFixed(cfg.precision)} Y${nextP[1].toFixed(cfg.precision)}`);
                }
            }

            // 4. Pen Up at end of chain
            lines.push(`G0 Z${cfg.zUp}`);
        });

        // Footer
        lines.push('G0 X0 Y0 ; Return Home');
        lines.push('M02 ; End of Program');

        return lines.join('\n');
    }
}
